require "./ast.cr"
require "./environment.cr"
require "./utils.cr"

# todo: create a map/enum/const for ananse typescript types
class CodeGenerator < AST::Visitor(Object)
  property newline = "\n"
  property environment : Environment = Environment.new

  # A stack which stores variable names (autogenerated) for display messages
  # in #generate_display_function and #visit_display_stmt.
  # A variable name is removed from the stack after executing a menu block
  # TODO: remove, not needed anymore
  property display_variable_names : Array(String) = [] of String

  # Tracks menu and class names
  property menu_class_names : Hash(String, String) = {} of String => String

  # get/post
  private property menu_context : Array(String) = [] of String

  alias ExpressionType = String | Int32 | Float64 | Bool | AST::Expr | Nil

  private getter runtime_imports = ["Request", "Response", "SessionMode", "Runtime", "isMatch"]

  private property ts : String::Builder = String::Builder.new("")

  def initialize(@ast : TransformedAST)
  end

  def generate : String
    # Add Ananse imports
    @ts << "import { " << @runtime_imports.join(", ") << " } from 'ananse';\n"
    # Add action names as import
    if !@ast.actions.empty?
      @ts << "import { " << @ast.actions.uniq.join(", ") << " } from './actions';\n"
    end

    fallback_menu_stub : String::Builder = String::Builder.new("")

    menu_handler_func = String.build do |s|
      s << "function menuHandler(runtime: Runtime) {\n"
      s << "const currentMenu: string | undefined = runtime.getCurrentMenu();\n"
      s << "switch (currentMenu) {\n"

      @ast.menus.each do |menu_name, definition|
        menu : AST::MenuStatement = definition["menu"].first.as(AST::MenuStatement)
        stmts : TransformedAST::GroupedStatements = definition

        @menu_context << "get"
        @menu_context << "post"

        runtime_id = menu.runtime_id
        s << %(case "#{runtime_id}_[GET]":\n)
        s << %(return #{runtime_id}(runtime, "get");\n)
        s << %(case "#{runtime_id}_[POST]":\n)
        s << %(return #{runtime_id}(runtime, "post");\n)

        @ts << execute(menu)
        # s << execute(menu)
        # s << generate_input_function(menu.name.value, definition["input"])
        # s << generate_display_function(menu.name.value, definition[:display])

        # if !definition[:option].empty?
        #   s << generate_options_code(definition[:option])
        # end

        # if !definition[:action].empty? || !definition[:input].empty?
        #   # TODO: add  as param and merge to generated code ?
        #   s << generate_action_function(action_stmts: definition["action"], input_stmts: definition["input"])
        # end

        # if !definition["end"].empty?
        #   s << generate_end_function(definition["end"])
        # end

        # s << generate_goto_function(menu.name.value, definition["goto"])
        # s << "}\n"

        # Add menus to router
        # @menu_class_names.each do |name, class_name|
        #   s << "MenuRouter.add(#{class_name}, '#{name}');\n"
        # end

        if menu.start?
          fallback_menu_stub << "if (runtime.session().mode() === SessionMode.start) {\n"
          fallback_menu_stub << %(runtime.setNextMenu("#{runtime_id}_[POST]");)
          fallback_menu_stub << %(return #{runtime_id}(runtime, "get");)
          fallback_menu_stub << "}\n" # close if
        end
      end

      s << "default:\n"
      s << fallback_menu_stub.to_s
      s << "runtime.endSession();"
      s << %(runtime.respond("Session cannot be retrieved");)

      s << "}\n" # close witch
      s << "}\n" # close function
    end

    @ts << menu_handler_func.to_s

    @ts << <<-JS
      export async function requestHandler(req: Request, resp: Response) {
        const runtime = await new Runtime(req, resp);
        await runtime.loadState();
        menuHandler(runtime);
      }
    JS
    return @ts.to_s
  end

  def visit_literal_expr(expr : AST::Literal) : String
    value : String = expr.value.to_s
    # puts expr.token
    case expr.token.type
    when TokenType::STRING
      # Fixup unbalanced quotes caused by strings with interpolation
      if value.starts_with?('"') && !value.ends_with?('"')
        value += '"'
      elsif !value.starts_with?('"') && value.ends_with?('"')
        value = '"' + value
      elsif !value.starts_with?('"') && !value.ends_with?('"')
        value = %("#{value}")
      elsif value == "\""
        value += '"'
      elsif value == " " # empty space, caused by multiple continuous interpolation
        value = %(" ")
      end
      value
    when Nil
      "null"
    else
      expr.value.to_s
    end
  end

  def visit_grouping_expr(expr : AST::Grouping) : ExpressionType
    "(#{evaluate(expr.expression)})"
  end

  def visit_unary_expr(expr : AST::Unary) : String?
    right : ExpressionType = evaluate(expr.right)
    op : String = expr.operator.value

    "#{op}#{right}"
    # case (expr.operator.type)
    # when TokenType::BANG
    #   return "!#{is_truthy?(right)}"
    # when TokenType::MINUS
    #   # return -(double)right;
    #   return "-#{right}"
    # end

    # # Unreachable.
    # return nil
  end

  def visit_binary_expr(expr : AST::Binary) : String?
    left : ExpressionType = evaluate(expr.left)
    right : ExpressionType = evaluate(expr.right)
    op : String = expr.operator.value

    "#{left} #{op} #{right}"
  end

  def visit_variable_expr(expr : AST::Variable) : Object
    %(await this.request.session.get("#{expr.name.value}"))
    # return @environment.get(expr.name)
  end

  private def evaluate(expr : AST::Expr) : ExpressionType
    expr.accept(self)
  end

  def visit_expression_stmt(stmt : AST::ExpressionStmt) : String
    evaluate(stmt.expression)
  end

  def visit_if_stmt(stmt : AST::IfStatement) : String
    # Skip code generation for empty if statement
    if stmt.then_branch.statements.size == 0 && stmt.else_branch.nil?
      return ""
    end

    code = String.build do |s|
      condition : String = "(#{evaluate(stmt.condition)})"

      # then branch might be empty after transformation
      # whilst the else branch is not empty.
      # We negate the condition and skip generating code for 'else'
      if stmt.then_branch.statements.size == 0 && !stmt.else_branch.nil?
        s << "if " << "(!#{condition})" << "{"
        s << execute(stmt.else_branch.as(AST::Stmt)) << "}"
      else
        s << "if " << condition << "{"
        s << execute(stmt.then_branch) << "}"
        if !stmt.else_branch.nil? && stmt.else_branch.as(AST::BlockStatement).statements.size > 0
          s << "else {" << execute(stmt.else_branch.as(AST::Stmt)) << "}"
        end
      end
    end

    return code.to_s
  end

  # Generates menu class definition code stub
  def visit_menu_stmt(stmt : AST::MenuStatement) : String
    # TODO: implement code generation for [POST] request

    runtime_id : String = stmt.runtime_id
    function = String.build do |s|
      if @menu_context.size == 2
        # just visited ast, generate initial code stubs
        s << "async function " << runtime_id << '('
        s << %(runtime: Runtime, type: "get" | "post") << "){"

        s << "const menuName = \"" << runtime_id << "\";"

        # Error message logic
        s << <<-JS
        const errorMessage: string | undefined = await runtime.getError(menuName);
        if (errorMessage != null) {
          // Add menu name back to stack
          if (runtime.getCurrentMenu() !== menuName) {
            runtime.setNextMenu(`${menuName}_[GET]`);
          }
          await runtime.clearError(menuName);
          return errorMessage;
        }
      JS
      end

      # Generates get request
      if in_get_context?
        s << %(if (type === "get") {\n)
        s << "let message: string = '';"

        # Add remaining logic, based on 'GET' request context
        s << execute(stmt.body)

        # Save state and return response
        s << "await runtime.saveState();"
        s << "return runtime.respond(message);"

        s << "}\n" # close 'get' if
      end

      # Generates get request
      if in_post_context?
        s << %(if (type === "post") {\n)
        s << execute(stmt.body)

        s << "}\n" # close 'post' if
      end

      if @menu_context.size == 1
        s << "}\n" # close function
      end
    end
    # class_name = "Menu_#{Util.generate_identifier_name(stmt.name.value)}".camelcase

    # # Track menu name and class name
    # # TODO: move this to ast transfer
    # @menu_class_names[stmt.runtime_id] = class_name

    # code = "export class #{class_name} extends BaseMenu {"
    # if !stmt.start.nil?
    #   code = <<-JS
    #     #{code}
    #     isStart(): Promise<boolean> | boolean {
    #       return true;
    #     }
    #   JS
    # end

    if @menu_context.empty?
      return function.to_s
    end

    @menu_context.shift

    @ts << function.to_s
    return execute(stmt)
  end

  def visit_block_stmt(block : AST::BlockStatement) : String
    code = String::Builder.new("")

    block.statements.each do |stmt|
      code << execute(stmt)
    end

    return code.to_s
  end

  def visit_end_stmt(stmt : AST::EndStatement) : String
    "runtime.endSession();"
  end

  def generate_end_function(end_stmts : Array(AST::Stmt)) : String
    stmts : Array(AST::Stmt) = end_stmts.sort_by { |stmt| stmt.location.line }

    code = String.build do |s|
      s << "async end() #{opening_brace}"

      if stmts.empty?
        s << "return false;#{closing_brace}"
        break
        # return s.to_s
      end

      str : String = ""
      stmts.each do |stmt|
        str += execute(stmt)
        str += @newline
      end

      # The runtime 'end()' API requires boolean return value.
      # However, in some instances, the generated snippet doesn't end with a 'return',
      # eg. when 'end' is in an if statement.
      # We fixup this by appending 'return false' to the code
      if /return (true|false);$/.match(str).nil?
        str += "return false;"
      end

      s << str << closing_brace
    end

    return code.to_s
  end

  # Generates code for `input` and `action` statements.
  #
  # The runtime represents `input` and `action` statements as a `MenuAction` object.
  # `input` is treated as an option statement that accepts any value.
  # `action` is generated as `MenuAction.handler` callback.
  #
  def generate_action_function(action_stmts : Array(AST::Stmt), input_stmts : Array(AST::Stmt))
    # Merge and sort (by line number) action and input statements
    # This ensures that the order of the generated codes matches closely with the source
    stmts : Array(AST::Stmt) = action_stmts.concat(input_stmts).sort_by { |stmt| stmt.location.line }

    # TODO: merge all action code into an option with .* choice
    code = String.build do |s|
      s << "async actions() #{opening_brace}"

      if stmts.empty?
        s << "return [];#{closing_brace}"
        return s.to_s
      end

      s << "return [{ choice: /.*/, display: undefined, handler: async (req: Request) => {"
      stmts.each do |stmt|
        s << execute(stmt) << @newline
      end
      s << "}}];" << closing_brace
    end

    return code.to_s
  end

  def generate_options_code(stmts : Array(AST::Stmt))
    code = String.build do |s|
      s << "async actions() #{opening_brace}"

      if stmts.empty?
        s << "return []; #{closing_brace}"
        return s.to_s
      end

      variable_name = "actions_list" # variable name for options
      s << "const #{variable_name}: MenuAction[] = [];\n"
      stmts.each do |stmt|
        s << execute(stmt)
      end

      s << "return " << variable_name << ";"
      s << closing_brace
    end

    return code.to_s
  end

  # Generates corresponding `nextMenu` function
  def generate_goto_function(menu : String, stmts : Array(AST::Stmt))
    code = String.build do |s|
      # TODO: implement 'input()' api for BaseMenu in the runtime
      s << "async nextMenu() #{opening_brace}"

      if stmts.empty?
        s << "return undefined; #{closing_brace}"
        return s.to_s
      end

      # item = stmts.find { |s| s.is_a?(AST::GotoStatement) }
      # if item.nil?
      #   raise Exception.new("No goto statement found in '#{menu}' menu")
      # end
      # item = item.as(AST::GotoStatement)

      variable_name = Util.generate_identifier_name
      s << "let #{variable_name} = '';\n"
      stmts.each do |stmt|
        if stmt.is_a?(AST::GotoStatement)
          s << "#{variable_name} = #{execute(stmt)};\n"
        else
          s << execute(stmt)
        end
      end

      s << "return " << variable_name << ";"
      s << closing_brace
    end

    return code.to_s
  end

  # Generates corresponding `message` function
  def generate_display_function(menu : String, stmts : Array(AST::Stmt))
    code = String.build do |s|
      # TODO: implement 'input()' api for BaseMenu in the runtime
      s << "async message() #{opening_brace}"

      if stmts.empty?
        s << "return undefined; #{closing_brace}"
        return s.to_s
      end

      # Push name to the stack
      variable_name = Util.generate_identifier_name
      @display_variable_names.unshift(variable_name)

      s << "let #{variable_name} = '';\n"
      stmts.each do |stmt|
        s << execute(stmt)
      end

      # Pop name from the stack
      @display_variable_names.shift

      s << "return " << variable_name << ";"
      s << closing_brace
    end

    return code.to_s
  end

  # Generates corresponding input function
  # def generate_input_function(menu : String, stmts : Array(AST::Stmt))
  #   # TODO: merge to gen action function
  #   code = String.build do |s|
  #     # TODO: implement 'input()' api for BaseMenu in the runtime
  #     s << "async input() #{opening_brace}"

  #     if stmts.empty?
  #       s << "return undefined; #{closing_brace}"
  #       return s.to_s
  #     end

  #     first_input = stmts.find { |s| s.is_a?(AST::InputStatement) }
  #     if first_input.nil?
  #       raise Exception.new("No input statement found in '#{menu}' menu")
  #     end

  #     stmts.each do |stmt|
  #       s << execute(stmt)
  #     end

  #     s << closing_brace
  #   end

  #   return code.to_s
  # end

  def visit_input_stmt(stmt : AST::InputStatement) : String
    if in_post_context?
      name : String = stmt.variable.value

      code = "const #{name} = runtime.userData();"
      code += %(await runtime.setValue("#{name}", #{name}))
      return code
    end

    return ""
  end

  def visit_option_stmt(stmt : AST::OptionStatement)
    if in_get_context?
      code = String::Builder.new("")
      stmt.group.each do |opt|
        code << "message += \n" << evaluate(opt) << "\n;"
      end

      return code.to_s
    end

    if in_post_context?
      code = String::Builder.new("")

      last_index = stmt.group.size - 1
      stmt.group.each_with_index do |opt, idx|
        if idx == 0
          code << "if "
        else
          code << "else if"
        end

        code << "(isMatch(runtime.userData(), #{opt.target.value})){\n"

        if !opt.action.nil? && !opt.next_menu.nil?
          # If both action & goto is defined,
          # then next_menu is called only if action result is truthy
          code << "if (" << evaluate(opt.action.as(AST::Action)) << "){\n"
          code << evaluate(opt.next_menu.as(AST::Goto))
          code << "}\n"
        elsif !opt.action.nil?
          code << evaluate(opt.action.as(AST::Action)) << ";"
        elsif !opt.next_menu.nil?
          code << evaluate(opt.next_menu.as(AST::Goto))
        end

        code << "}\n" # close if/else
      end

      return code.to_s
    end
    return ""
  end

  def visit_option_expr(expr : AST::Option) : String
    if in_get_context?
      return %(#{expr.label.value})
    end

    # TODO: implement post
    code = String.build do |s|
      # TODO: check token type, if number/string, add to label
      # s << "{" << "choice: #{expr.target.value},"
      # s << "display: #{expr.label.value},"
      # if !expr.next_menu.nil?
      #   s << "next_menu: '#{expr.next_menu.as(AST::Goto).name.value}',"
      # end
      # if !expr.action.nil?
      #   s << "next_menu: async(req, res) => {"
      #   s << evaluate(expr.action.as(AST::Action))
      #   s << "},"
      # end
      # s << "}"
    end
    return code.to_s
  end

  def visit_action_stmt(stmt : AST::ActionStatement) : String
    return evaluate(stmt.expression)
  end

  def visit_action_expr(expr : AST::Action) : String
    code : String = "await #{expr.func_name.value}({"

    expr.params.each_key do |key|
      code += "#{key.value}:"
      param : Token = expr.params[key]

      if param.type == TokenType::IDENTIFIER
        code += "await runtime.getValue('#{param.value}'),"
      else
        code += "#{param.value},"
      end
    end
    code += "});"

    if expr.name != nil
      var_name = Util.generate_identifier_name
      code = <<-JS
          const #{var_name} = #{code}
          await req.session.set("#{expr.name.as(Token).value}", #{var_name});
        JS
    end

    return code
  end

  def visit_goto_stmt(stmt : AST::GotoStatement) : String
    return evaluate(stmt.menu)
  end

  def visit_goto_expr(expr : AST::Goto) : String
    name : String = @ast.symbol_table.lookup_goto_target(expr.name).runtime_id
    stub = String.build do |s|
      s << "await runtime.removeCurrentMenu(); // remove current menu from the stack\n"
      s << %(runtime.setNextMenu("#{name}_[GET]"); // push new menu onto the stack\n)
      s << "await runtime.saveState();"
      s << %(return #{name}(runtime, "get"))
    end

    return stub.to_s
  end

  def visit_interpolation_expr(str : AST::InterpolatedString) : String
    last_idx : Int32 = str.expressions.size - 1

    if last_idx == -1
      return ""
    end

    output = String.build do |s|
      str.expressions.each_with_index do |expr, i|
        s << evaluate(expr)
        if i != last_idx
          s << '+'
        end
      end
    end

    return output.to_s
  end

  # TODO: remove this
  # FIXME: rename to log?
  def visit_print_stmt(stmt : AST::Print) : String
    value : ExpressionType = evaluate(stmt.expression)
    return "console.log(#{value});"
  end

  # TODO: remove this
  def visit_variable_stmt(stmt : AST::VariableStmt)
    # value : String = ""
    # if !stmt.initializer.nil?
    #   value = evaluate(stmt.initializer.as(AST::Expr))
    # end

    @environment.define(stmt.name.value, "false")
    return "const #{stmt.name.value} = value;"
  end

  def visit_variable_stmt(stmt : AST::VariableStatement) : String
    name = evaluate(stmt.name)
    # @environment.define(stmt.name, false)
    # TODO: relook at this
    return "#TODO: to be implemented"
  end

  def visit_display_stmt(stmt : AST::DisplayStatement) : String
    if in_get_context?
      return "message = #{evaluate(stmt.expression)};\n"
    end

    return ""
  end

  private def in_get_context?
    @menu_context.first? == "get"
  end

  private def in_post_context?
    @menu_context.first? == "post"
  end

  # Returns a closing brace with a newline
  private def closing_brace : String
    "}\n"
  end

  private def opening_brace : String
    "{\n"
  end

  def execute(stmt : AST::Stmt) : String
    stmt.accept(self)
  end
end
